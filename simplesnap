#!/bin/bash

# Simple snapshot manager

# Copyright (c) 2014 John Goerzen
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.

set -e

logit () {
   logger -p info -t "`basename $0`[$$]" "$1"
}

exiterror () {
   logit "$1"
   echo "$1" 1>&2
   exit 10
}

syntaxerror () {
   cat <<EOF
Syntax: 

$0 [--sshcmd CMD] [--local] --store SORE --setname NAME --host HOST

or

$0 --check TIMEFRAME --store STORE --setname NAME [--host HOST]

Required:

  --store: gives the ZFS dataset name where data will be stored.  Mountpoint
           is inferred.
  --setname: Gives the backup set name.  Can just be a made-up word
             if multiple sets aren not needed; for instance, the hostname
             of the backup server.  This is used in the snapshot name.
  --host: Gives the hostname to back up.

Optional:

  --sshcmd: Gives the SSH command.  Defaults to "ssh".  Example:
            --sshcmd "ssh -i /root/.id_rsa_simplesnap"
  --wrapcmd: Gives the path to simplesnapwrap on the remote
             (or local machine, if --local is present).
             Not usually relevant, since this is set in
             ~/.ssh/authorized_keys.  Default: "simplesnapwrap"
  --local: The host is localhost; do not use remote tool to access it.
  --check: Do not back up, but check existing backups.  If any are
           older than TIMEFRAME, print an error and exit with a nonzero
           code.  Scans all hosts unless a specific host is given with
           --host.  The parameter is in the format given to date/gdate: 
           for instance, --check "30 days ago".  Remember to enclose it
           in quotes if it contains spaces.
EOF
  exiterror "Syntax error: $1"
}

while [ -n "$1" ]; do
  case "$1" in
    "--sshcmd")
      SSHCMD="$2"
      shift 2
      ;;
    "--wrapcmd")
      WRAPCMD="$2"
      shift 2
      ;;
    "--store")
      STORE="$2"
      shift 2
      ;;
    "--setname")
      SETNAME="$2"
      shift 2
      ;;
    "--host")
      HOST="$2"
      shift 2
      ;;
    "--check")
      CHECKMODE="$2"
      if [ -z "$CHECKMODE" ] ; then
          syntaxerror "--check requires a paremter"
      fi
      shift 2
      ;;
    "--local")
      LOCALMODE="on"
      shift
      ;;
    *)
      syntaxerror "Unknown option \"$1\""
      ;;
  esac
done

SSHCMD="${SSHCMD:-ssh}"
WRAPCMD="${WRAPCMD:-simplesnapwrap}"

DATE="gdate"
gdate &> /dev/null || DATE="date"
SED="gsed"
gsed &> /dev/null || SED="sed"
GREP="ggrep"
ggrep &> /dev/null || GREP="grep"


# Validating
[ -n "$SSHCMD" ] || syntaxerror "Invalid SSH command: $SSHCMD"
[ -n "$STORE" ] || syntaxerror "Missing --store"
[ -n "$SETNAME" ] || syntaxerror "Missing --setname"
[ -n "$CHECKMODE" -o -n "$HOST" ] || syntaxerror "Missing --host"

echo "_${STORE}" | $GREP -qv " " || syntaxerror "Space in --store: ${STORE}"
TEMPLATEPATTERN="^[a-zA-Z0-9]\+\$"
echo "a${SETNAME}" | $GREP -q "${TEMPLATEPATTERN}" || syntaxerror "Invalid characters in setname \"${SETNAME}\"; pattern is \"${TEMPLATEPATTERN}\""
echo "_${SETNAME}" | $GREP -qv '^_-' || syntaxerror "Set name cannot begin with a dash: \"${SETNAME}\""
TEMPLATE="__simplesnap_${SETNAME}_"

MOUNTPOINT="`zfs list -H -o mountpoint -t filesystem \"${STORE}\"`"

logit "Store ${STORE} is mounted at ${MOUNTPOINT}"

cd "${MOUNTPOINT}"

# template - $1
# dataset - $2
listsnaps () {
   runzfs list -t snapshot -r -d 1 -H -o name "$2" | $GREP "@$1" || true
}

CHECKRETVAL=0

runzfs () {
  logit "Running /sbin/zfs $*"
  /sbin/zfs "$@"
}

checkbackups () {
  CHECKHOST="$1"
  DATASETS="`runzfs list -t filesystem,volume -o name -H -r \"${STORE}/${HOST}\"`"
  CUTOFF="`$DATE -d \"${CHECKMODE}\" +%s`"
  for CHECKDS in ${DATASETS}; do
    FOUNDOK=0
    # Extract timestamps
    for TIMESTAMP in `listsnaps "$TEMPLATE" "$CHECKDS" | $SED 's/^.*_\([^_]\+__\)$/\1/'`; do
        TSSEC=`$DATE -d "${TIMESTAMP}" +%s`
        if [ "$TSSEC" -gt "$CUTOFF" ]; 
            then FOUNDOK=1
        fi
    done
    if [ "$FOUNDOK" = "0" ]; then
        echo "${CHECKDS} last back up is too old!" 1>&2
        CHECKRETVAL=10
    fi
  done 
}

if [ -n "$CHECKMODE" ]; then
  # Do a check only.
  if [ -n "$HOST" ]; then
    checkbackups "$HOST"
  else
    for HOST in *; do checkbackups "$HOST"; done
  fi
  logit "check: exiting with value $CHECKRETVAL"
  exit $CHECKRETVAL
fi

runwrap () {
  if [ "$LOCALMODE" = "on" ]; then
    logit "Running on localhost: $WRAPCMD reinvoked $*"
    "${WRAPCMD}" reinvoked "$@"
  else
    logit "Running $SSHCMD $WRAPCMD $*"
    ${SSHCMD} ${HOST} ${WRAPCMD} "$@"
  fi
}

if [ ! -d "${MOUNTPOINT}/${HOST}" ]; then
  runzfs create "${STORE}/${HOST}"
fi

LOCKFILE="${MOUNTPOINT}/${HOST}/.lock"

if dotlockfile -l -p "${LOCKFILE}"; then
  LOCKMETHOD="dotlockfile"
  logit "Lock obtained at ${LOCKFILE} with dotlockfile"
  trap "ECODE=$?; dotlockfile -u \"${LOCKFILE}\"; exit $?" EXIT INT TERM
else
  RETVAL="$?"
  if [ "$RETVAL" = "127" ]; then
    LOCKMETHOD="mkdir"
    mkdir "${LOCKFILE}" || exiterror "Could not obtain lock at ${LOCKFILE}; if $0 is not already running, rmdir that path."
    logit "Lock obtained at ${LOCKFILE} with mkdir"
    trap "ECODE=$?; rmdir \"${LOCKFILE}\"" EXIT INT TERM
  else
    exiterror "Could not obtain lock at ${LOCKFILE}; $0 likely already running."
  fi
fi


reap () {
  DATASET="$1"
       # We always save the most recent.
       SNAPSTOREMOVE="`listsnaps \"${TEMPLATE}\" \"${DATASET}\" | head -n -1`"
       if [ -z "${SNAPSTOREMOVE}" ]; then
         logit "No snapshots to remove."
       else
         for REMOVAL in ${SNAPSTOREMOVE}; do
            logit "Destroying snapshot ${REMOVAL}"
            echo "_${REMOVAL}" | $GREP -q '@' || exiterror "PANIC: snapshot name doesn not contain @"
            runzfs destroy "${REMOVAL}"
         done
       fi
}
  

logit "Finding remote datasets to back up"

REMOTEDATASETS="`runwrap listfs`"
for DATASET in ${REMOTEDATASETS}; do
  if runwrap sendback "${SETNAME}" "${DATASET}" | \
     runzfs receive -F "${STORE}/${HOST}/${DATASET}"; then
      logit "Received backup into ${STORE}/${HOST}/${DATASET}."
      runwrap reap "${SETNAME}" "${DATASET}"
      reap "${STORE}/${HOST}/${DATASET}"
  else
      logit "zfs receive died with error: $?"
      exit 100
  fi        
done

